//gtx 1050ti : 6x128 core = 768 ----- 48x128 Grid = 6144
//gtx 1660ti : 16x64 core = 1024 -----128x128 grid = 16384
//gtx 3060ti : 38x128 core = 4864 ---- 304x128 girc = 38912


// KeyHunt* v 
// v->Search(gpuId, gridSize, should_exit);
// 	-> search()   ========================================> ( ---- WHILE ---- )  - isAlive                          / WHILE _A_
// 		---> SetupRanges(nbGPUThread);
//         		-->	pthread_create(&thread_id, NULL, &_FindKeyGPU, (void*)(params + (i))); 
                //       --> _FindKeyGPU() ================> ( --- WHILE --- ) --------   ok = g->LaunchSEARCH_MODE_SA   /  WWHILE _B_
                //              ---> g = new GPUEngine()     
                                // ok = g->SetKeys(p); --> gộp callKernelSEARCH_MODE_SA( -> return true )  
                                // 	-> compute_keys_comp_mode_sa           // lặp lại in hàng nghìn lần
                                // 	-> ComputeKeysSEARCH_MODE_SA     // đã đc gộp vào compute_keys_comp_mode_sa  // lặp lại in hàng nghìn lần
                                // 		-> CheckHashSEARCH_MODE_SA     // lặp lại in hàng nghìn lần


//thử tắt while _A_ 				
//-------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------



//2 //  __global__ void compute_keys_comp_mode_sa                                    
		// 	int xPtr = (blockIdx.x * blockDim.x) * 8;
		// 	int yPtr = xPtr + 4 * blockDim.x;
		// 	ComputeKeysSEARCH_MODE_SA(keys + xPtr, keys + yPtr); //outputBuffer = found = Out bên gpuCompute.h 

//3 // __device__ void ComputeKeysSEARCH_MODE_SA(uint64_t* startx, uint64_t* starty  //


// keys = inputKey 
// startx = keys + xPtr
// starty = keys + yPtr 
					// 	xPtr = (blockIdx.x * blockDim.x) * 8;
					// 	yPtr = xPtr + 4 * blockDim.x;



// # // Allocate memory
// # nbThread = 6144
// # CudaSafeCall(cudaMalloc((void**)&inputKey, nbThread * 32 * 2));
// # CudaSafeCall(cudaHostAlloc(&inputKeyPinned, nbThread * 32 * 2, cudaHostAllocWriteCombined | cudaHostAllocMapped));


// # nbThread * 32 * 2: This expression calculates the total amount of memory to allocate.
// # nbThread (6144) is the number of threads.
// # 32 likely represents the size (in bytes) of data each thread will handle (perhaps each key consists of multiple components).
// # 2 indicates that each key is represented using two components (for example, a point in elliptic curve cryptography might require both x and y coordinates).
// # Overall, this line allocates enough memory on the GPU for 6144 keys, with each key being 64 bytes (32 bytes for x and 32 bytes for y).



//-------------------------------------------------------------------------------------------
union {
	uint32_t bits[NB32BLOCK];
	uint64_t bits64[NB64BLOCK];
};

#define LoadI64(i,i64)    \
i.bits64[0] = i64;        \
i.bits64[1] = i64 >> 63;  \
i.bits64[2] = i.bits64[1];\
i.bits64[3] = i.bits64[1];\
i.bits64[4] = i.bits64[1];

Int(int64_t i64);

Int::Int(int64_t i64) {
	if (i64 < 0) {	CLEARFF();	}
	else {	CLEAR(); }
	bits64[0] = i64;
}

p.x = "EFB1CA1CE468A6C1A8255532BE01EF2B016B81859A2A258F644C926695B1DD25";

a[0] = p.x.bits64[0];
a[1] = p.x.bits64[1];
a[2] = p.x.bits64[2];
a[3] = p.x.bits64[3]; 







typedef struct Point {
	INT X;
	INT Y;

	#ifdef __cplusplus
	Point(): X(0), Y(0) {}
	Point(INT x, INT y): X(x), Y(y) {}
	Point(const Point& point): X(point.X), Y(point.Y) {}
	Point(const Size& size): X(size.Width), Y(size.Height) {}
	
	BOOL Equals(const Point& point) const {
		return X == point.X && Y == point.Y;
	}
	Point operator+(const Point& point) const {
		return Point(X + point.X, Y + point.Y);
	}
	Point operator-(const Point& point) const {
		return Point(X - point.X, Y - point.Y);
	}
	#endif /* __cplusplus */
} Point;
//-------------------------------------------------------------------------------------------

// ------ setKey() : 
// inputKeyPinned[48255]   p[6143].x.bits64[0] : 2901984113303037752
// inputKeyPinned[48383]   p[6143].x.bits64[1] : 3695036346887650317
// inputKeyPinned[48511]   p[6143].x.bits64[2] : 7746298158958007612
// inputKeyPinned[48639]   p[6143].x.bits64[3] : 11003281272133564957
// --------------------------------------------------------------------
// inputKeyPinned[48767]   p[6143].y.bits64[0] : 15750634579094711184
// inputKeyPinned[48895]   p[6143].y.bits64[1] : 8699382898088163141
// inputKeyPinned[49023]   p[6143].y.bits64[2] : 11007718672821264594
// inputKeyPinned[49151]   p[6143].y.bits64[3] : 4398735010385563036




///////////////////////////////////////////

	uint64_t* inputKey;
	uint64_t* inputKeyPinned;

		// Allocate memory
	CudaSafeCall(cudaMalloc((void**)&inputKey, nbThread * 32 * 2));
	CudaSafeCall(cudaHostAlloc(&inputKeyPinned, nbThread * 32 * 2, cudaHostAllocWriteCombined | cudaHostAllocMapped));
	
	gán giá trị ----

	CudaSafeCall(cudaMemcpy(inputKey, inputKeyPinned, nbThread * 32 * 2, cudaMemcpyHostToDevice));

	CudaSafeCall(cudaFreeHost(inputKeyPinned));
	inputKeyPinned = NULL;